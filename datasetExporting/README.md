These scripts are responsible for cleaning the resulting csv files from the simulations and sending them to the IoT platform.

CSVcleaning.py cleans the csv files generated with scavetool from the .sca and .vec files generated by the simulation.

transformToSD.py trasnforms the cleaned csv files to the SmartData format and sends them to the IoT platform.

Below is the mapping of variable name and unit, and the mapping of variable name and transformation function:

# Define the mapping

```python
mapping = {
    "transmissionState:vector": 0xF8000006,
    "passedUpPk:vector(count)": 0xF8000006,
    "droppedPkWrongPort:vector(count)": 0xF8000006,
    "droppedPkBadChecksum:vector(count)": 0xF8000006,
    "servingCell:vector": 0xF8000006,
    "txPk:vector(packetBytes)": 0x03000000, # bits *8
    "rxPkOk:vector(packetBytes)": 0x03000000, # bits *8
    "passedUpPk:vector(packetBytes)": 0x03000000, # bits *8
    "receivedPacketFromLowerLayer:vector(packetBytes)": 0x03000000, # bits *8
    "posLongCar:vector": 0xC4B24924, # *pi/180
    "posLatCar:vector": 0xC4B24924, # *pi/180
    "posZCar:vector": 0xC4964924,
    "packetSent:vector(packetBytes)": 0x03000000, # bits *8
    "rcvdPkFromHl:vector(packetBytes)": 0x03000000, # bits *8
    "receivedPacketFromUpperLayer:vector(packetBytes)": 0x03000000, # bits *8
    "sentPacketToLowerLayer:vector(packetBytes)": 0x03000000, # bits *8
    "packetReceived:vector(packetBytes)": 0x03000000, # bits *8
    "harqErrorRate_1st_Ul:vector": 0xF8000001,
    "harqErrorRateUl:vector": 0xF8000001,
    "harqErrorRate_2nd_Ul:vector": 0xF8000001,
    "harqTxAttemptsUl:vector": 0xF8000006,
    "sentPacketToUpperLayer:vector(packetBytes)": 0x03000000, # bits *8
    "rlcPacketLossUl:vector": 0xF8000001,
    "harqErrorRate_3rd_Ul:vector": 0xF8000001,
    "rlcPacketLossD2D:vector": 0xF8000001,
    "rlcPacketLossTotal:vector": 0xF8000001,
    "rlcPduPacketLossD2D:vector": 0xF8000001,
    "queueLength:vector": 0x03010000, # pk
    "queueBitLength:vector": 0x03000000, # b
    "distance:vector": 0x84964924, 
    "incomingPacketLengths:vector": 0x03000000, # b
    "queueingTime:vector": 0x84925924,
    "outgoingPacketLengths:vector": 0x03000000, # b
    "avgServedBlocksUl:vector": 0x03020000, # blocks
    "avgServedBlocksDl:vector": 0x03020000, # blocks
    "measuredSinrUl:vector": 0xF8000000,	
    "measuredSinrDl:vector": 0xF8000000,	
    "alertDelay:vector": 0x84925924,
    "alertRcvdMsg:vector": 0x84925924,
    "averageCqiUl:vector": 0x03030000,
    "rcvdSinrUl:vector": 0xF8000000,
    "macDelayUl:vector": 0x84925924,
    "averageCqiD2D:vector": 0x03030000,
    "macDelayDl:vector": 0x84925924,
    "rlcPduThroughputD2D:vector": 0x03040000, # Bps *8
    "rlcPduDelayD2D:vector": 0x84925924,
    "rlcThroughputD2D:vector": 0x03040000, # Bps *8
    "rlcDelayD2D:vector": 0x84925924,
    "incomingDataRate:vector": 0x03040000, # bps
    "outgoingDataRate:vector": 0x03040000, # bps
}

transformations = { 
    "txPk:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "rxPkOk:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "passedUpPk:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "receivedPacketFromLowerLayer:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "posLongCar:vector": lambda x: x * 3.141592653589793 / 180, # *pi/180 
    "posLatCar:vector": lambda x: x * 3.141592653589793 / 180, # *pi/180 
    "packetSent:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "rcvdPkFromHl:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "receivedPacketFromUpperLayer:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "sentPacketToLowerLayer:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "packetReceived:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "sentPacketToUpperLayer:vector(packetBytes)": lambda x: x * 8, # bits *8 
    "rlcPduThroughputD2D:vector": lambda x: x * 8, # Bps *8 
    "rlcThroughputD2D:vector": lambda x: x * 8
}

```

Besides that the SmartData Model (how we transform data to SmartData format) is the following:

```python

dev_index = list(mapping.keys()).index(name)

smartdata = {
    'smartdata': [
        {
            'version': '1.2',
            'unit': int(hex(unit), 16),
            'value': float(value) if name not in transformations else transformations[name](float(value)),
            #'error': 0,
            #'confidence': 0,
            'x': x,
            'y': y,
            'z': z,
            't': to_unix_microseconds(ts),
            'dev': dev_index,
            'signature': modules.index(module),
            #'workflow': 0,
        }
    ]
}

# modules is a list with all the modules that are being used in the simulation
```

And for the series:

```python

series = { 
    'series' : {
        'version' : '1.2',
        'unit' : int(hex(unit), 16),
        'x' : 0,
        'y' : 0,
        'z' : 0,
        'r' : 0,
        't0' : to_unix_microseconds(vectime[0]),
        't1' : to_unix_microseconds(vectime[-1]),
        #'workflow' : 0,
        'dev' : dev_index,
        'signature' : smartdata_dict[key][0]['smartdata'][0]['signature'],
    }
}

```

vectorsReport.txt is a file with a report on the current variables in the simulation and their units (even the ones that do not have a unit predefined by the simulator)